[Back to **Initial conditions**](InitCond.md)

# Fitting

The third step in the modeling run is fitting of all models from the given initial conditions. This task is performed by a specific external module called `LevMar`. For more direct control, the user may either choose to launch all fits of a given category or launch one individual fit from a specified initial condition. We will examine both possibilities in the following.

## The `LevMar` module

The basic fitting module can be launched by the corresponding function called `LevMar()`:

```
import RTModel
rtm = RTModel.RTModel('/event001')
rtm.Reader()
rtm.InitCond()
rtm.LevMar('PS0000')
```

With this code, we first perform the data pre-processing by `Reader`, we set the initial conditions by `InitCond` and finally launch the fit of the single-lens-single-source model from the first initial condition found in the file `InitCondPS.txt` (see [Initial conditions](InitCond.md)). Initial condition seeds in each `InitCondXX.txt` file are numbered starting from zero (e.g. `PS0011` would be the 12th initial condition).

In the `/event001` directory you will see that the following products appear:
- In the subfolder `ini/`, the file `LevMar.ini` appears, which contains the current options with which `LevMar` has been launched. 
- In the same subfolder, the file `Parameters_Ranges.ini` appears, containing the ranges and the maximum step for each parameter.
- A new subdirectory called `PreModels/` is created with a file `minchi.dat`. This file contains the value of the minimum chi square among all  preliminary models contained in the subdirectories within `PreModels/`.
- In the subdirectory `PreModels/` there will be a file numbered `PS0000.txt` containing the preliminary models found by this run of `LevMar`.

After the execution of `LevMar`, you may call the `run()` function to complete the modeling run or continue with other calls to `LevMar()`, depending on your intentions.

## Launching all fits for a specific category

The `LevMar()` function only launches one fit and will be rarely useful to a generic user, except for checking or repeating a specific initial condition. More interesting is the `launch_fits()` function, that launches all fits for a specific model category:

```
import RTModel
rtm = RTModel.RTModel('/event001')
rtm.Reader()
rtm.InitCond()
rtm.launch_fits('PS')
```

In this code, the `launch_fits()` will launch all fits of the `'PS'` [model category](ModelCategories.md) using all available processors or those that have been indicated by the users through the `set_processors()` function (see [Modeling Run](ModelingRun.md)). A progress bar will inform the user of the fits completed and those yet to be done.

At the end of the execution of the `launch_fits()` function, the `PreModels/` directory will have a file  `'PS.txt'` containing all models found from all initial conditions in `InitCondPS.txt`. The file `minchi.dat` will contain the minimum chi square found so far, with the name of the the best model.

The following step would be the [Model selection](ModelSelection.md) within the fitted model category. After that, the preliminary models in `/PreModels` will no longer be used and can be deleted to save disk space by a call to `rtm.cleanup_preliminary_models()`

## Launching a fit from a user-defined initial condition

If you want to run a fit from a set of parameters outside the set of initial conditions generated by `InitCond`, you may write the parameters in a file or directly give the parameters to `LevMar` as an argument:

```
rtm.LevMar('LSmyfit', parameters_file = 'myinitialcondition.txt')
```

In this case, `LevMar` will perform a static binary-lens fit starting from the initial conditions found in the file 'myinitialcondition.txt'. The results will still be placed in `PreModels/LSmyfit.txt` similarly to the previous case. It is important to notice that the model category is read from the first two characters of the first argument. We also note that the obtained results will be taken in consideration in the process of [Model selection](ModelSelection.md) on equal footing as standard fits obtained from the initial conditions generated by `InitCond`.

The parameters file should just contain the starting parameters in the first line separated by spaces. The order of the parameters is specified in [Model categories](ModelCategories.md). Any additional lines are ignored. Indeed, the output models generated by `LevMar` are perfectly valid initial conditions for the same model category and can be used in consecutive runs.

In alternative, we may specify the parameters directly in the call to `LevMar`:
```
rtm.LevMar('LSmyfit', parameters = [1.2, 0.01, 0.23, 1.5, 0.001, 25.2, 6573.2])
```

The order of parameters for each model category is specified in [Model categories](ModelCategories.md).

## The Levenberg-Marquardt fit

The `LevMar` module executes a number of Levenberg-Marquardt fits from the specified initial condition in order to minimize the chi square. Every time a minimum is found, it is filled with a 'bumper'. Any subsequent run hitting the bumper will be bounced off in a different direction in the parameter space. In this way, new minima can be found from the same initial condition.

If any [constraints](Constraints.md) have been specified by the `set_constraints()` function, they will be taken into account at this stage.

The details of this fitting strategy are illustrated in the [RTModel paper](https://ui.adsabs.harvard.edu/abs/2024A%26A...688A..83B/abstract). 

## Options for fitting

### The `config_LevMar()` function

The user may specify his/her own options to drive the initial conditions to the desired result by calling the `config_InitCond()` function with the proper options:

```
import RTModel
rtm = RTModel.RTModel('/event001')
rtm.config_LevMar(self, nfits = 6, offsetdegeneracy = 3, timelimit = 600.0, maxsteps = 50, bumperpower = 2.0, 
                      mass_luminosity_exponent = 4.0, mass_radius_exponent = 0.9, lens_mass_luminosity_exponent =4.0, 
                     turn_off_secondary_source = False, turn_off_secondary_lens = False)

rtm.run()
```

The call to `config_LevMar()` will affect all following executions of the `LevMar` module, whether called through `run()` or `launch_fits()` or `LevMar()`. If you want to change your options, you may call `config_LevMar()` again.

### Description of the options

Here we describe the options for `LevMar` in detail indicating their default values.

- `nfits = 6`: Number of fits executed from the same initial condition.
- `offsetdegeneracy = 3`: Number of fits to be executed after applying the [offset degeneracy](https://ui.adsabs.harvard.edu/abs/2022NatAs...6..782Z/abstract) reflection.
- `maxsteps = 50`: Maximum number of steps for each fit.
- `timelimit = 600.0`: Maximum time in seconds allowed for the execution of `LevMar`. If the limit is reached, the execution of the individual fitting is stopped and only the minima found so far will be saved.
- `bumperpower = 2.0`: Size of the bumper in the parameter space expressed in sigmas. The bumper is created with the shape determined by the local covariance matrix. and the size given by this parameter.
- `turn_off_secondary_source = False`: if set, the secondary source flux will be set to zero. This is useful to model a source orbiting around a dark object. In this case, the model `BS` has no difference from `PS` and should be removed. We also suggest to set the mass_luminosity_exponent to 1.0 so that the flux ratio parameter is converted to a mass-ratio parameter.
- `turn_off_secondary_lens = False`: if set, the secondary lens flux will be set to zero. This only affects astrometric trajectories very weakly for binary lens models. It has been introduced to cover the case of a binary lens in which a star orbits a dark object.
- `mass_luminosity_exponent = 4.0`: in binary source models it is used to relate the flux ratio parameter with the mass ratio.
- `mass_radius_exponent = 0.9`: in binary source models it is used to relate the mass ratio with the radius ratio.
- `lens_mass_luminosity_exponent = 4.0`: affects the calculation of the center of light in astrometric trajectories for binary lens models.

All options are also accessible separately as properties of the `RTModel` class. The user may thus modify the value of each option one by one. The names of the properties are the same as the options in `config_LevMar()` with the prefix `LevMar_`, as shown in the example below:

```
rtm.LevMar_nfits = 1
rtm.LevMar_timelimit = 1200.0
```

An empty call to `config_LevMar()` with no parameters will reset all variables to the default values. Notice that the options that are not explicitly specified in the call to `config_LevMar()` are always reset to their default values. This is also true if you previously used the `recover_options()` function to inherit the options from a previous run (see [Archiving and updating](Archive.md)).

### Recording the options

In each modeling run, the options for `LevMar` are stored in the file `LevMar.ini` in the `/ini` subdirectory within the event directory for later reference. If the modeling run is [archived](Archive.md), also the whole `/ini` subdirectory is saved so that the user may check the options used in each modeling run. The function `recover_options()` can be used to load the options from a previous run.

## Parameters ranges and step sizes

Each parameter is left free to vary within a well-defined range. In addition, the maximum variation allowed for a parameter in an individual Levenberg-Marquardt step is also defined in `RTModel`. The values of minimum, maximum and step size for each parameter are stored in the property `parameters_ranges`. For example, if you want to check the default values for the `PS` model category, you may write

```
print(rtm.parameters_ranges['PS'])
```

The output will be
```
[[-11.0, 1.0, 1.0], [-4.6, 7.6, 1.0], [-300, 300, 5.0], [-11.5, 2.3, 2.3]]
```
This is a list of four triples (one for each parameter). Each triple contains the minimum value, the maximum value and the maximum step size for each parameter. The order of parameters is the same specified in [Model Categories](ModelCategories.md). If the parameter is fit through its logarithm, these values refer to the logarithm. For example, for the single-lens-single-source model here, the first parameter is `log_u0`.

The user may freely change these values. For example, if you want to allow the fit to go as far as `tE = 10000`, you may add the line
```
rtm.parameters_ranges['PS'][1][2] = math.log(10000)
```

All single-lens-single-source fits following this line will be affected.

Note that the [Constraints](Constraints.md) imposed by `set_constraints()` are gaussian constraints that will still respect the limits imposed by the parameters ranges specified here. So, the user has actually two different ways to control the parameter space in which the fit will move.

[Go to **Model selection**](ModelSelection.md)
